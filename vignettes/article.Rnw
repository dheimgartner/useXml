\documentclass[a4paper]{article}
\usepackage{minimal}

%\VignetteIndexEntry{Let's use the extensible markup language (XML)!}
%\VignetteDepends{foo}
%\VignettePackage{useXml}

\usepackage[svgnames]{xcolor}
\usepackage[nochapters,eulermath=true]{classicthesis}
\usepackage{natbib}

%% recommended packages
\usepackage{orcidlink,thumbpdf}
\usepackage{framed}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pmboxdraw}
\usepackage{float}

\bibliographystyle{minimal}

\setlength{\marginparwidth}{4cm}
\setlength{\marginparsep}{0.4cm}
\setlength{\marginparpush}{0.75cm}
\hypersetup{citecolor=teal}

\usepackage{minted}
\newminted{bash}{bgcolor=Beige, bgcolorpadding=0.5em}
\newcommand{\bash}[1]{\mintinline{bash}|#1|}

\newminted{xml}{bgcolor=Beige, bgcolorpadding=0.5em}
\newcommand{\xml}[1]{\mintinline{xml}|#1|}

\newcommand{\use}[1]{\code{#1}}

\newcommand{\XML}{\proglang{XML}}

\SweaveOpts{engine=R, eps=FALSE, keep.source = TRUE}
<<preliminaries, echo=FALSE, results=hide>>=
options(prompt = " ",  continue = "   ", width = 70, useFancyQuotes = FALSE)
library("useXml")
@

\author{Daniel Heimgartner}

\title{Let's use the extensible markup language (XML)!}

\begin{document}
\maketitle

\url{https://www.w3schools.com/xml/default.asp}

This is \XML:
%
\begin{xmlcode}
 <?xml version="1.0" encoding="UTF-8"?>
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note>
\end{xmlcode}
%
What do you think the above information represents? What could you do with the above representation?

\section{Extensible markup what?}

\leftmarginpar{What is \proglang{XML}}
\begin{itemize}
\item Foo.
\item What is the purpose?
\begin{itemize}
\item Storing information/state in a generic universal (meta-) representation.
\item Easily transferable from one process to another (serializing and deserializing).
\item Object (in JS) $\Rightarrow$ \XML $\Rightarrow$ Object (in Python).
\item Or similarly: Orbeon Form Builder $\Rightarrow$ \XML $\Rightarrow$ Orbeon Form Runner.
\end{itemize}
\item What is markup? ``marking something up'' has for me the connotation of providing extra information...
\item Extensible in what sense?
\item Difference to \proglang{JSON}?
\end{itemize}

\begin{xmlcode}
 <?xml version="1.0" encoding="UTF-8"?>
<person>
  <name>Daniel</name>
  <age>33</age>
</person>
\end{xmlcode}
%
What datatype should \xml{<age>33</age>} be? We need a way to say: ``Hey, if you parse (read) the \XML-File (which is just a text file) and consume the data, be aware that 'age' is an integer!''. Whereas \proglang{JSON} embodies that information directly in the source, \XML~does not...

\marginpar{This is just a marginpar...}

\leftmarginpar{Why should we care/use it?}
\begin{itemize}
\item Foo.
\end{itemize}

\leftmarginpar{Some terminology}
\begin{itemize}
\item \proglang{xPath}, \proglang{XML Schema}, \proglang{XSLT}, \proglang{DTD}, etc.
\end{itemize}

\leftmarginpar{What will I learn?}
\begin{itemize}
\item Foo.
\item Learn where to learn more!
\end{itemize}

\section{Let's get started}

In the remainder, we will omit the header \xml{<?xml version="1.0" encoding="UTF-8"?>} to save some space...

\leftmarginpar{Attributes}
Let's revisit the person representation from above. Do we need a tag for any information?
%
\begin{xmlcode}
<person age="33" name="Daniel Heimgartner"/>
\end{xmlcode}
%
There are two things we should note: 1. A tag can take attributes in a \code{key="value"} fashion, and 2. If an element does not contain any children, it can be self-closing -- i.e., \xml{<person age="33" name="Daniel Heimgartner"/>} is equivalent to \xml{<person age="33" name="Daniel Heimgartner"></person>}.

What's the difference to something like this:
%
\begin{xmlcode}
<person age="33">
  <name>Daniel Heimgartner</name>
</person>
\end{xmlcode}
%
I.e., we are essentially contrasting \textbf{attributes} vs. \textbf{child elements} in \XML... Which one is to be preferred? I think attributes should be used to indicate that the value is modified in some way. A classical example would be a style attribute, i.e., an additional peace of information that is not the part of the main information content, but specifies how this main information is presented (e.g., \xml{<text size="12">foo</text>}).

\section{XML schema}

\url{https://www.w3schools.com/xml/schema_intro.asp}

\leftmarginpar{What is an XML schema?}
\begin{itemize}
\item Remember what we've said earlier about the data types?
\item An \XML~schema describes the structure of an \XML~document and is itself written as \XML. Kind of elegant, no?
\end{itemize}

\section{XML and Excel}
\marginpar{The ``x'' in \code{.docx}, \code{.xlsx}, etc. actually is a reminecense of \XML. Change the ending of any such file to \code{.zip} and extract it to see that it is just a collection of files and in particular contains an XML representing the document structure/data.}
%
Excel + \XML~schema = \XML?

\section{XML and R}

\leftmarginpar{Basic example}
% maybe use examples from above...
<<>>=
library(xml2)
xml <- '
<people>
  <person>
    <name>Daniel</name>
    <age>33</age>
  </person>
  <person>
    <name>Adrian</name>
    <age>73</age>
  </person>
</people>
'

xml_parsed <- xml2::read_xml(xml)
xml2::as_list(xml_parsed)
@
%
So without a Schema, the parser does not know that age is an integer...

\leftmarginpar{Providing an XML Schema}

\leftmarginpar{Querying with xPath}
It is actually ``impossible'' to access the second person (Adrian) in the list above. Let's use xPath!
<<>>=
person_2 <- xml2::xml_find_all(xml_parsed, xpath = "/people/person[2]")
xml2::xml_find_all(xml_parsed, xpath = "/people/person[last()]")  # equivalent
@


\leftmarginpar{The magic of XSLT}
Transforming to HTML!

\section{Now it's your turn!}

Little exercise...

\section{Resources}
\begin{itemize}
\item Foo
\end{itemize}

\bibliography{refs}

\end{document}
